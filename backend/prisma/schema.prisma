// ═══════════════════════════════════════════════════════════════
// Production-Grade Video Conferencing Platform - Prisma Schema
// ═══════════════════════════════════════════════════════════════
// Database: PostgreSQL (control-plane only, real-time state in Redis)
// ORM: Prisma
// Backend: NestJS
// Design Principles:
// - Migration-safe and extensible
// - Explicit relation tables (no polymorphic garbage)
// - Clear ownership semantics
// - Safe evolution paths
// - Enterprise-grade audit trail
// ═══════════════════════════════════════════════════════════════

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ═══════════════════════════════════════════════════════════════
// ENUMS
// ═══════════════════════════════════════════════════════════════

/// User authentication provider type
enum AuthProviderType {
  LOCAL    // Username/password
  GOOGLE   // OAuth Google
  GITHUB   // OAuth GitHub
  MICROSOFT // OAuth Microsoft
  APPLE    // OAuth Apple
  SAML     // Future SAML SSO
  
  @@map("auth_provider_type")
}

/// Room lifecycle status
enum RoomStatus {
  CREATED   // Room created but not started (waiting room)
  LIVE      // Active meeting in progress
  ENDED     // Meeting ended normally
  CANCELLED // Meeting cancelled before starting
  
  @@map("room_status")
}

/// Participant role within a specific room
enum ParticipantRole {
  HOST        // Full control: kick, mute all, close room, recordings
  CO_HOST     // Elevated: kick, mute all (but cannot close room)
  PARTICIPANT // Basic: speak, share, chat
  
  @@map("participant_role")
}

/// Recording lifecycle status
enum RecordingStatus {
  STARTED     // Recording initiated
  IN_PROGRESS // Recording in progress (chunks being written)
  STOPPED     // Recording stopped normally
  FAILED      // Recording failed (storage/encoding error)
  PROCESSING  // Post-processing (transcoding, thumbnail generation)
  READY       // Ready for playback
  
  @@map("recording_status")
}

/// Audit event types (immutable security trail)
enum AuditAction {
  // Authentication
  USER_REGISTERED
  USER_LOGIN_SUCCESS
  USER_LOGIN_FAILED
  USER_LOGOUT
  
  // Room lifecycle
  ROOM_CREATED
  ROOM_STARTED
  ROOM_ENDED
  ROOM_CANCELLED
  
  // Participant actions
  USER_JOINED
  USER_LEFT
  USER_KICKED
  USER_BANNED
  
  // Permissions
  ROLE_CHANGED
  ROLE_PROMOTION
  ROLE_DEMOTION
  
  // Media control
  USER_MUTED
  USER_UNMUTED
  ALL_MUTED
  SCREEN_SHARE_STARTED
  SCREEN_SHARE_STOPPED
  
  // Recording
  RECORDING_STARTED
  RECORDING_STOPPED
  RECORDING_DELETED
  
  // WebRTC media
  PRODUCER_CREATED
  PRODUCER_CLOSED
  CONSUMER_CREATED
  CONSUMER_CLOSED
  
  // Security
  UNAUTHORIZED_ACCESS_ATTEMPT
  RATE_LIMIT_EXCEEDED
  SUSPICIOUS_ACTIVITY
  
  @@map("audit_action")
}

// ═══════════════════════════════════════════════════════════════
// CORE MODELS
// ═══════════════════════════════════════════════════════════════

/// Users - Central identity model
/// Soft deletes supported for GDPR compliance and audit trail integrity
model User {
  id           String   @id @default(uuid()) @db.Uuid
  username     String   @unique @db.VarChar(100)
  email        String?  @unique @db.VarChar(255) // Optional for OAuth-only users
  passwordHash String?  @db.VarChar(255) // Nullable for OAuth-only users
  displayName  String   @db.VarChar(150)
  
  // Account status
  isActive     Boolean  @default(true)
  isVerified   Boolean  @default(false) // Email verification status
  
  // Soft delete (NEVER hard delete users - audit trail dependency)
  deletedAt    DateTime? @db.Timestamptz(3)
  
  // Timestamps
  createdAt    DateTime @default(now()) @db.Timestamptz(3)
  updatedAt    DateTime @updatedAt @db.Timestamptz(3)
  lastLoginAt  DateTime? @db.Timestamptz(3)
  
  // Relations
  authProviders    AuthProvider[]     // Multiple OAuth providers per user
  ownedRooms       Room[]             // Rooms where user is the owner
  participations   RoomParticipant[]  // Room participation history
  auditLogs        AuditLog[]         // User-initiated audit events
  recordingsOwned  Recording[]        @relation("RecordingOwner")
  
  // Indexes for performance
  @@index([email])
  @@index([username])
  @@index([isActive, deletedAt]) // Active user queries
  @@index([createdAt])
  @@map("users")
}

/// AuthProvider - Supports multiple identity providers per user
/// Future-proof for OAuth, SAML, LDAP, etc.
model AuthProvider {
  id             String           @id @default(uuid()) @db.Uuid
  userId         String           @db.Uuid
  providerType   AuthProviderType
  providerId     String           @db.VarChar(255) // External provider's user ID
  providerEmail  String?          @db.VarChar(255) // Email from provider
  
  // OAuth tokens (encrypted at rest)
  accessToken    String?          @db.Text // If we need to make API calls
  refreshToken   String?          @db.Text
  tokenExpiresAt DateTime?        @db.Timestamptz(3)
  
  // Provider-specific metadata (scopes, profile URL, etc.)
  metadata       Json?            @db.JsonB
  
  // Timestamps
  createdAt      DateTime         @default(now()) @db.Timestamptz(3)
  updatedAt      DateTime         @updatedAt @db.Timestamptz(3)
  lastUsedAt     DateTime?        @db.Timestamptz(3)
  
  // Relations
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Prevent duplicate provider linkages
  @@unique([providerType, providerId])
  @@index([userId])
  @@index([providerType, providerId])
  @@map("auth_providers")
}

/// Room - Represents a video conference meeting (scheduled or instant)
/// Control-plane only - real-time state (participants, media) lives in Redis
model Room {
  id              String      @id @default(uuid()) @db.Uuid
  
  // Ownership
  ownerId         String      @db.Uuid
  
  // Room identity
  roomCode        String      @unique @db.VarChar(20) // Human-readable join code
  title           String      @db.VarChar(255)
  description     String?     @db.Text
  
  // Scheduling support
  scheduledStart  DateTime?   @db.Timestamptz(3)
  scheduledEnd    DateTime?   @db.Timestamptz(3)
  
  // Capacity & settings
  maxParticipants Int         @default(100) @db.Integer
  isPublic        Boolean     @default(false) // Public rooms allow anyone with code
  isRecordable    Boolean     @default(true)  // Allow recordings
  requireAuth     Boolean     @default(true)  // Must be authenticated to join
  
  // Lifecycle
  status          RoomStatus  @default(CREATED)
  startedAt       DateTime?   @db.Timestamptz(3) // When first participant joined
  endedAt         DateTime?   @db.Timestamptz(3) // When host closed or last left
  
  // Analytics (computed from Redis or aggregated)
  peakParticipants Int        @default(0) @db.Integer
  totalJoins       Int        @default(0) @db.Integer
  durationSeconds  Int?       @db.Integer // Computed: endedAt - startedAt
  
  // Soft delete (preserve meeting history)
  deletedAt       DateTime?   @db.Timestamptz(3)
  
  // Timestamps
  createdAt       DateTime    @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime    @updatedAt @db.Timestamptz(3)
  
  // Relations
  owner           User        @relation(fields: [ownerId], references: [id], onDelete: Restrict)
  participants    RoomParticipant[]
  recordings      Recording[]
  auditLogs       AuditLog[]
  
  // Indexes for query performance
  @@index([ownerId])
  @@index([roomCode])
  @@index([status])
  @@index([scheduledStart])
  @@index([createdAt])
  @@index([status, startedAt]) // Active rooms query
  @@index([ownerId, status])   // User's active rooms
  @@map("rooms")
}

/// RoomParticipant - Explicit many-to-many relation between User and Room
/// Tracks full participation lifecycle including kicks, bans, role changes
model RoomParticipant {
  id          String          @id @default(uuid()) @db.Uuid
  
  // Relations
  userId      String          @db.Uuid
  roomId      String          @db.Uuid
  
  // Role & permissions in this specific room
  role        ParticipantRole @default(PARTICIPANT)
  
  // Participation lifecycle
  joinedAt    DateTime        @default(now()) @db.Timestamptz(3)
  leftAt      DateTime?       @db.Timestamptz(3)
  
  // Kick/ban support
  isKicked    Boolean         @default(false)
  kickedAt    DateTime?       @db.Timestamptz(3)
  kickedBy    String?         @db.Uuid // User ID who kicked
  kickReason  String?         @db.VarChar(500)
  
  isBanned    Boolean         @default(false) // Prevents rejoining
  bannedAt    DateTime?       @db.Timestamptz(3)
  bannedBy    String?         @db.Uuid
  banReason   String?         @db.VarChar(500)
  
  // Analytics
  durationSeconds Int?        @db.Integer // Computed: leftAt - joinedAt
  
  // Relations
  user        User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  room        Room            @relation(fields: [roomId], references: [id], onDelete: Cascade)
  
  // A user can have multiple participation records in same room (rejoin support)
  // But only ONE active participation at a time
  @@unique([userId, roomId, joinedAt]) // Composite unique for rejoin tracking
  @@index([userId])
  @@index([roomId])
  @@index([roomId, leftAt])        // Active participants query
  @@index([userId, leftAt])        // User's active rooms
  @@index([roomId, role])          // Host/co-host lookup
  @@index([isBanned, roomId])      // Ban enforcement
  @@map("room_participants")
}

/// Recording - Meeting recording metadata and lifecycle
/// Actual media files stored in S3/GCS (URL reference only)
model Recording {
  id              String          @id @default(uuid()) @db.Uuid
  
  // Ownership
  roomId          String          @db.Uuid
  ownerId         String          @db.Uuid // User who started recording (usually host)
  
  // Storage reference (NOT the file itself)
  storageKey      String          @unique @db.VarChar(500) // S3/GCS object key
  storageUrl      String?         @db.Text // Presigned URL or CDN URL
  storageBucket   String          @db.VarChar(100)
  
  // Recording metadata
  filename        String          @db.VarChar(255)
  sizeBytes       BigInt?         @db.BigInt // File size
  durationSeconds Int?            @db.Integer // Video duration
  
  // Video specifics
  codec           String?         @db.VarChar(50)   // e.g., 'vp8', 'h264'
  resolution      String?         @db.VarChar(20)   // e.g., '1920x1080'
  fps             Int?            @db.Integer
  bitrate         Int?            @db.Integer       // kbps
  
  // Lifecycle
  status          RecordingStatus @default(STARTED)
  startedAt       DateTime        @default(now()) @db.Timestamptz(3)
  stoppedAt       DateTime?       @db.Timestamptz(3)
  
  // Error tracking
  errorMessage    String?         @db.Text
  retryCount      Int             @default(0) @db.Integer
  
  // Access control
  isPublic        Boolean         @default(false)
  expiresAt       DateTime?       @db.Timestamptz(3) // Auto-delete old recordings
  
  // Soft delete (GDPR/retention policy)
  deletedAt       DateTime?       @db.Timestamptz(3)
  
  // Timestamps
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)
  
  // Relations
  room            Room            @relation(fields: [roomId], references: [id], onDelete: Restrict)
  owner           User            @relation("RecordingOwner", fields: [ownerId], references: [id], onDelete: Restrict)
  
  // Indexes
  @@index([roomId])
  @@index([ownerId])
  @@index([status])
  @@index([storageKey])
  @@index([createdAt])
  @@index([expiresAt])              // Cleanup job
  @@index([roomId, status])         // Room's recordings
  @@map("recordings")
}

/// AuditLog - Immutable security and compliance audit trail
/// Append-only design (never update or delete)
/// Partitioned by date for performance at scale
model AuditLog {
  id          String      @id @default(uuid()) @db.Uuid
  
  // What happened
  action      AuditAction
  
  // Who did it
  userId      String?     @db.Uuid // Nullable for system-initiated events
  
  // Where did it happen
  roomId      String?     @db.Uuid // Room context if applicable
  
  // Additional context
  targetUserId String?    @db.Uuid // For actions affecting another user (kick, role change)
  metadata     Json?      @db.JsonB // Flexible event-specific data
  
  // Network context
  ipAddress    String?    @db.Inet
  userAgent    String?    @db.VarChar(500)
  
  // Timestamp (immutable)
  timestamp    DateTime   @default(now()) @db.Timestamptz(3)
  
  // Relations (SET NULL to preserve audit trail if entities deleted)
  user         User?      @relation(fields: [userId], references: [id], onDelete: SetNull)
  room         Room?      @relation(fields: [roomId], references: [id], onDelete: SetNull)
  
  // Indexes for audit queries
  @@index([userId])
  @@index([roomId])
  @@index([action])
  @@index([timestamp(sort: Desc)])        // Most recent first
  @@index([userId, timestamp(sort: Desc)]) // User activity timeline
  @@index([roomId, timestamp(sort: Desc)]) // Room event log
  @@index([action, timestamp(sort: Desc)]) // Security monitoring
  @@map("audit_logs")
}

// ═══════════════════════════════════════════════════════════════
// INDEXING STRATEGY NOTES
// ═══════════════════════════════════════════════════════════════
// 
// Performance-critical queries:
// 1. Active rooms lookup:       rooms[status, startedAt]
// 2. User's active rooms:       room_participants[userId, leftAt]
// 3. Room participants:         room_participants[roomId, leftAt]
// 4. Ban enforcement:           room_participants[isBanned, roomId]
// 5. Audit trail search:        audit_logs[userId|roomId, timestamp DESC]
// 6. Recording cleanup:         recordings[expiresAt]
// 7. Auth provider lookup:      auth_providers[providerType, providerId]
// 
// Composite indexes chosen for:
// - Covering index optimization (Postgres index-only scans)
// - Avoiding full table scans on time-series queries
// - Supporting pagination with consistent sort order
// 
// ═══════════════════════════════════════════════════════════════
