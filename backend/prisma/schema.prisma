generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "linux-musl-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

/// Users - Central identity model
/// Soft deletes supported for GDPR compliance and audit trail integrity
model User {
  id              String            @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  email           String            @unique(map: "UQ_97672ac88f789774dd47f7c8be3") @db.VarChar(255)
  passwordHash    String            @db.VarChar(255)
  isActive        Boolean           @default(true)
  createdAt       DateTime          @default(now()) @db.Timestamptz(6)
  updatedAt       DateTime          @default(now()) @updatedAt @db.Timestamptz(6)
  role            users_role_enum   @default(STUDENT)
  displayName     String            @db.VarChar(100)
  bio             String?           @db.Text
  profilePictureUrl String?         @db.VarChar(500)
  specialties     String[]
  emailVerified    Boolean           @default(false)
  verificationToken String?          @db.VarChar(255)
  verificationTokenExpires DateTime? @db.Timestamptz(6)
  resetToken       String?           @db.VarChar(255)
  resetTokenExpires DateTime?       @db.Timestamptz(6)
  auditLogs       AuditLog[]
  authProviders   AuthProvider[]
  meetings        meetings[]
  recordingsOwned Recording[]       @relation("RecordingOwner")
  participations  RoomParticipant[]
  ownedRooms      Room[]
  transactions    Transaction[]
  wallet          Wallet?
  chatMessages    ChatMessage[]
  questions       Question[]
  upvotes         QuestionUpvote[]

  @@index([email], map: "IDX_97672ac88f789774dd47f7c8be")
  @@map("users")
}

model Wallet {
  id        String   @id(map: "PK_8402e5df5a30a229380e83e4f7e") @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  userId    String   @unique(map: "IDX_2ecdb33f23e9a6fc392025c0b9") @db.Uuid
  balance   Int      @default(0)
  createdAt DateTime @default(now()) @db.Timestamptz(6)
  updatedAt DateTime @default(now()) @updatedAt @db.Timestamptz(6)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_2ecdb33f23e9a6fc392025c0b97")

  @@map("wallets")
}

model Transaction {
  id                    String                   @id(map: "PK_a219afd8dd77ed80f5a862f1db9") @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  userId                String                   @db.Uuid
  meetingId             String?                  @db.Uuid
  type                  transactions_type_enum
  amount                Int
  status                transactions_status_enum @default(pending)
  providerTransactionId String?                  @db.VarChar(255)
  metadata              Json?
  createdAt             DateTime                 @default(now()) @db.Timestamptz(6)
  user                  User                     @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_6bb58f2b6e30cb51a6504599f41")
  meetings              meetings?                @relation(fields: [meetingId], references: [id], onUpdate: NoAction, map: "FK_d9de21333ef897deda930257597")

  @@index([userId], map: "IDX_6bb58f2b6e30cb51a6504599f4")
  @@index([meetingId], map: "IDX_d9de21333ef897deda93025759")
  @@map("transactions")
}

/// AuthProvider - Supports multiple identity providers per user
/// Future-proof for OAuth, SAML, LDAP, etc.
model AuthProvider {
  id             String           @id @default(uuid()) @db.Uuid
  userId         String           @db.Uuid
  providerType   AuthProviderType
  providerId     String           @db.VarChar(255)
  providerEmail  String?          @db.VarChar(255)
  accessToken    String?
  refreshToken   String?
  tokenExpiresAt DateTime?        @db.Timestamptz(3)
  metadata       Json?
  createdAt      DateTime         @default(now()) @db.Timestamptz(3)
  updatedAt      DateTime         @updatedAt @db.Timestamptz(3)
  lastUsedAt     DateTime?        @db.Timestamptz(3)
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([providerType, providerId])
  @@index([userId])
  @@index([providerType, providerId])
  @@map("auth_providers")
}

/// Room - Represents a video conference meeting (scheduled or instant)
/// Control-plane only - real-time state (participants, media) lives in Redis
model Room {
  id               String      @id @default(uuid()) @db.Uuid
  ownerId          String      @db.Uuid
  roomCode         String      @unique @db.VarChar(20)
  title            String      @db.VarChar(255)
  description      String?
  scheduledStart   DateTime?   @db.Timestamptz(3)
  scheduledEnd     DateTime?   @db.Timestamptz(3)
  maxParticipants  Int         @default(100)
  isPublic         Boolean     @default(false)
  isRecordable     Boolean     @default(true)
  requireAuth      Boolean     @default(true)
  status           RoomStatus  @default(CREATED)
  startedAt        DateTime?   @db.Timestamptz(3)
  endedAt          DateTime?   @db.Timestamptz(3)
  peakParticipants Int         @default(0)
  totalJoins       Int         @default(0)
  durationSeconds  Int?
  deletedAt        DateTime?   @db.Timestamptz(3)
  createdAt        DateTime    @default(now()) @db.Timestamptz(3)
  updatedAt        DateTime    @updatedAt @db.Timestamptz(3)
  recordings       Recording[]
  owner            User        @relation(fields: [ownerId], references: [id])

  @@index([ownerId])
  @@index([roomCode])
  @@index([status])
  @@index([scheduledStart])
  @@index([createdAt])
  @@index([status, startedAt])
  @@index([ownerId, status])
  @@map("rooms")
}

/// RoomParticipant - Explicit many-to-many relation between User and Room
/// Tracks full participation lifecycle including kicks, bans, role changes
model RoomParticipant {
  id              String    @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  userId          String    @db.Uuid
  roomId          String    @db.Uuid
  joinedAt        DateTime  @default(now()) @db.Timestamptz(6)
  leftAt          DateTime? @db.Timestamptz(6)
  isKicked        Boolean   @default(false)
  kickedAt        DateTime? @db.Timestamptz(6)
  kickedBy        String?   @db.Uuid
  kickReason      String?   @db.VarChar(500)
  isBanned        Boolean   @default(false)
  bannedAt        DateTime? @db.Timestamptz(6)
  bannedBy        String?   @db.Uuid
  banReason       String?   @db.VarChar(500)
  durationSeconds Int?
  role            String    @default("PARTICIPANT") @db.VarChar(50)
  user            User      @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_2fffd7766a5c57a31e8e81c1b40")

  @@unique([userId, roomId, joinedAt], map: "IDX_5ace18777b8f88bfe6d4b3e6c9")
  @@index([userId], map: "IDX_2fffd7766a5c57a31e8e81c1b4")
  @@index([roomId, role], map: "IDX_563e667d18098c72537b741ad8")
  @@index([roomId, leftAt], map: "IDX_7e8aadd9ed43a9ce4148de3812")
  @@index([userId, leftAt], map: "IDX_81316b3c844d3b09e7d6447e7d")
  @@index([roomId], map: "IDX_e5a9c5cf868f51dabb972930d4")
  @@map("room_participants")
}

/// Recording - Meeting recording metadata and lifecycle
/// Actual media files stored in S3/GCS (URL reference only)
model Recording {
  id              String          @id @default(uuid()) @db.Uuid
  roomId          String          @db.Uuid
  ownerId         String          @db.Uuid
  storageKey      String          @unique @db.VarChar(500)
  storageUrl      String?
  storageBucket   String          @db.VarChar(100)
  filename        String          @db.VarChar(255)
  sizeBytes       BigInt?
  durationSeconds Int?
  codec           String?         @db.VarChar(50)
  resolution      String?         @db.VarChar(20)
  fps             Int?
  bitrate         Int?
  status          RecordingStatus @default(STARTED)
  startedAt       DateTime        @default(now()) @db.Timestamptz(3)
  stoppedAt       DateTime?       @db.Timestamptz(3)
  errorMessage    String?
  retryCount      Int             @default(0)
  isPublic        Boolean         @default(false)
  expiresAt       DateTime?       @db.Timestamptz(3)
  deletedAt       DateTime?       @db.Timestamptz(3)
  createdAt       DateTime        @default(now()) @db.Timestamptz(3)
  updatedAt       DateTime        @updatedAt @db.Timestamptz(3)
  owner           User            @relation("RecordingOwner", fields: [ownerId], references: [id])
  room            Room            @relation(fields: [roomId], references: [id])

  @@index([roomId])
  @@index([ownerId])
  @@index([status])
  @@index([storageKey])
  @@index([createdAt])
  @@index([expiresAt])
  @@index([roomId, status])
  @@map("recordings")
}

/// AuditLog - Immutable security and compliance audit trail
/// Append-only design (never update or delete)
/// Partitioned by date for performance at scale
model AuditLog {
  id        String                 @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  action    audit_logs_action_enum
  userId    String?                @db.Uuid
  roomId    String?                @db.Uuid
  metadata  Json?
  ipAddress String?                @db.Inet
  createdAt DateTime               @default(now()) @db.Timestamptz(6)
  user      User?                  @relation(fields: [userId], references: [id], onUpdate: NoAction, map: "FK_cfa83f61e4d27a87fcae1e025ab")

  @@index([roomId], map: "IDX_3c868775b83bc1eaa72de9251a")
  @@index([action], map: "IDX_cee5459245f652b75eb2759b4c")
  @@index([userId], map: "IDX_cfa83f61e4d27a87fcae1e025a")
  @@map("audit_logs")
}

model meetings {
  id               String               @id(map: "PK_aa73be861afa77eb4ed31f3ed57") @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  title            String               @db.VarChar(255)
  roomCode         String               @unique(map: "UQ_bad0d82fe56792d4a051f63a79b") @db.VarChar(20)
  hostId           String               @db.Uuid
  status           meetings_status_enum @default(waiting)
  maxParticipants  Int                  @default(100)
  startedAt        DateTime?            @db.Timestamptz(6)
  endedAt          DateTime?            @db.Timestamptz(6)
  peakParticipants Int                  @default(0)
  createdAt        DateTime             @default(now()) @db.Timestamptz(6)
  updatedAt        DateTime             @default(now()) @db.Timestamptz(6)
  scheduledStart   DateTime?            @db.Timestamptz(6)
  scheduledEnd     DateTime?            @db.Timestamptz(6)
  description      String?              @db.Text
  price            Int                  @default(0)
  category         String?              @db.VarChar(100)
  thumbnailUrl     String?              @db.VarChar(500)
  tags             String[]
  users            User                 @relation(fields: [hostId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "FK_f4c16c40d16a9eb2003c5dd1ff2")
  transactions     Transaction[]
  chatMessages     ChatMessage[]
  questions        Question[]

  @@index([roomCode], map: "IDX_bad0d82fe56792d4a051f63a79")
  @@index([hostId], map: "IDX_f4c16c40d16a9eb2003c5dd1ff")
}

enum TransactionType {
  TOPUP
  DEBIT
  REFUND
}

enum TransactionStatus {
  PENDING
  SUCCESS
  FAILED
}

/// User authentication provider type
enum AuthProviderType {
  LOCAL
  GOOGLE
  GITHUB
  MICROSOFT
  APPLE
  SAML

  @@map("auth_provider_type")
}

/// Room lifecycle status
enum RoomStatus {
  CREATED
  LIVE
  ENDED
  CANCELLED

  @@map("room_status")
}

/// Recording lifecycle status
enum RecordingStatus {
  STARTED
  IN_PROGRESS
  STOPPED
  FAILED
  PROCESSING
  READY

  @@map("recording_status")
}

enum audit_logs_action_enum {
  room_created
  room_closed
  user_joined
  user_left
  user_kicked
  user_muted
  all_muted
  role_changed
  producer_created
  producer_closed
  consumer_created
  hand_raise_toggled
}

enum meetings_status_enum {
  waiting
  active
  closed
  scheduled
  cancelled
}

enum users_role_enum {
  STUDENT
  TEACHER
  ADMIN
}

enum transactions_status_enum {
  pending
  success
  failed
}

enum transactions_type_enum {
  topup
  debit
  refund
}

/// ChatMessage - Persistent storage for room chats
model ChatMessage {
  id           String    @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  roomId       String    @db.Uuid
  userId       String    @db.Uuid
  content      String?   @db.Text
  type         String    @default("text") @db.VarChar(20) // text, file, private
  targetUserId String?   @db.Uuid
  fileUrl      String?   @db.VarChar(500)
  fileName     String?   @db.VarChar(255)
  fileSize     Int?
  fileType     String?   @db.VarChar(100)
  isDeleted    Boolean   @default(false)
  createdAt    DateTime  @default(now()) @db.Timestamptz(6)
  
  // ...
  meeting      meetings  @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([roomId])
  @@index([createdAt])
  @@map("chat_messages")
}

/// Question - Q&A module for sessions
model Question {
  id           String           @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  roomId       String           @db.Uuid
  userId       String           @db.Uuid
  content      String           @db.Text
  isAnswered   Boolean          @default(false)
  isApproved   Boolean          @default(true) // For moderated Q&A
  createdAt    DateTime         @default(now()) @db.Timestamptz(6)
  
  meeting      meetings         @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  upvotes      QuestionUpvote[]

  @@index([roomId])
  @@index([isAnswered])
  @@map("questions")
}

/// QuestionUpvote - Tracking user upvotes on questions
model QuestionUpvote {
  id         String   @id @default(dbgenerated("uuid_generate_v4()")) @db.Uuid
  questionId String   @db.Uuid
  userId     String   @db.Uuid
  createdAt  DateTime @default(now()) @db.Timestamptz(6)

  question   Question @relation(fields: [questionId], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([questionId, userId])
  @@map("question_upvotes")
}
